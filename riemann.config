(require '[riemann.logging :as logging])
(require '[riemann.influxdb :refer [influxdb]])
(require '[clojure.string :as str])

;; Logging
(logging/init {:file "/var/log/riemann/riemann.log"})

;; Riemann input servers
(tcp-server {:host "0.0.0.0" :port 5555})
(udp-server {:host "0.0.0.0" :port 5555})

;; InfluxDB connection settings
(def influxdb-creds {:host "192.168.64.9"
                     :port 8086
                     :db "riemann"
                     :version :1})

(def influx-sender (influxdb influxdb-creds))

;; Convert attribute list to map
(defn attr-map [event]
  (into {} (for [a (:attributes event)]
             [(:key a) (:value a)])))

;; Safely parse a value to double if possible, else nil
(defn safe-parse-double [v]
  (cond
    (number? v) v
    (string? v) (try (Double/parseDouble v) (catch Exception _ nil))
    :else nil))

;; Normalize event, convert rt/ut to numbers, print types, send to InfluxDB
(defn normalize-and-send [event]
  (let [attrs (attr-map event)
        method (get attrs "method" "unknown")
        response-code (get attrs "response_code" "unknown")
        agent (get attrs "agent" "unknown")
        ip (get attrs "ip" "unknown")
        path (get attrs "path" "unknown")
        ;; Apply safe-parse-double to both top-level and attr value
        rt (safe-parse-double (or (:rt event) (get attrs "rt")))
        ut (safe-parse-double (or (:ut event) (get attrs "ut")))
        host (:host event)]
    (when (not= host "top-master")
      (info (str "rt value: " rt ", datatype: " (type rt)
                 " | ut value: " ut ", datatype: " (type ut)))
      (let [new-event (-> event
                          (assoc :service "nginx_logs_v2")
                          (assoc :tags {:method method
                                        :response_code response-code
                                        :agent agent
                                        :ip ip
                                        :path path})
                          (cond-> rt (assoc :rt rt))
                          (cond-> ut (assoc :ut ut)))]
        (info "Influx Payload: " new-event)
        (influx-sender new-event)))))

;; Main stream - filter out "top-master", process others
(let [index (index)]
  (streams
    index
    (fn [event]
      (when (not= (:host event) "top-master")
        (info "Received event: " event)
        (normalize-and-send event))
      nil)))
